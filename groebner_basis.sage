def s_polynomial(f, g):
    """
    params: f, g: polynomials
    return: S-polynomial(f, g)
    """
    gamma = lcm(f.lm(), g.lm())
    f_mult, g_mult = gamma//f.lt(), gamma//g.lt()
    return expand(f_mult*f - g_mult*g), f_mult, g_mult


def div_alg(functions, f, g):
    """
    Multivariate division of functions on S-poly(f, g). 
    param: functions: list[polynomials]
    param: f, g: two polynomials in functions
    return: divides: type(bool): 
        True: if remainder of S-poly on set = 0
        False: otherwise
    """
    f_idx, g_idx = functions.index(f), functions.index(g)
    s_poly = s_polynomial(f, g)
    divides = False
    print("S({}, {}) = {}".format(f, g, s_poly[0]))

    try:
        mult = s_poly[0].lift(Ideal(functions))
        if s_poly[1] != mult[f_idx] and s_poly[2] != mult[g_idx]:  # if not generated by the def of s-polynom
            divides = True                      
            print("{} =  {} * {}^T, \n" .format(s_poly[0], mult, functions))
        else:
            print "Non-zero Remainder. Add to Basis \n"                   
    except ValueError:  # does not divide
        print "Non-zero Remainder. Add to Basis \n"
                                                 
    return divides

def groeb_basis(functions, used_pairs):
    """
    Loops over S-pairs, adding S-polys to list of functions if remainder on functions != 0.
    param: functions: list[polynoms]
    param: used_pairs: list[tuple(f, g)]: list of S-pairs that have already been checked
    return: functions: add s-poly to list if div_alg = False
    """
    for f in functions:
        for g in functions:
            if (f != g) and ((f, g) not in used_pairs) and (s_polynomial(f, g)[0] != 0):
                used_pairs += [(f, g)]
                print "Basis", functions
                if not div_alg(functions, f, g):  # s-poly not in ideal
                    functions += [s_polynomial(f, g)[0]]
                    return groeb_basis(functions, used_pairs)  # recheck if new set is groeb basis
                elif (f, g) == (functions[-2], functions[-1]):  # s-poly is in ideal and (f,g) last s-pair
                    return functions
 

if __name__ == '__main__':
    R.<x,y> = PolynomialRing(QQ, order='lex')
    polynomials = input("Generating polynomials: ")  # example: [x**2 + 2*x*y**2, x*y + 2*y**3 - 1]
    gb = groeb_basis(polynomials, [])
    print '\n', "Pre-Reduced Groebner Basis", gb
    GB = ideal(polynomials).groebner_basis()
    print"Reduced Groebner Basis", GB
